/**
 * 
 */
/**
 * 代理模式是对象的结构模式。代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用。
 * 
 * 所谓代理，就是一个人或者机构代表另一个人或者机构采取行动。在一些情况下，一个客户不想或者不能够直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。
 * 
 * 在代理模式中的角色：
　　●　　抽象对象角色：声明了目标对象和代理对象的共同接口，这样一来在任何可以使用目标对象的地方都可以使用代理对象。
　　●　　目标对象角色：定义了代理对象所代表的目标对象。
　　●　　代理对象角色：代理对象内部含有目标对象的引用，从而可以在任何时候操作目标对象；代理对象提供一个与目标对象相同的接口，以便可以在任何时候替代目标对象。代理对象通常在客户端调用传递给目标对象之前或之后，执行某个操作，而不是单纯地将调用传递给目标对象。
 *
 *根据以上对代理的理解，对于代理的具体实现，我们有不同的方式，如果按照代理的创建时期，代理类可以分为两种。：静态代理、动态代理。
 *
 *静态代理：由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了。 
 *
 *动态代理：在程序运行时，运用反射机制动态创建而程。
 *
 *而动态代理又分为JDK动态代理和CGLIB动态代理
 *
 *a.一个比较直观的方式，就是定义一个功能接口，然后让Proxy 和RealSubject来实现这个接口。
 *b.还有比较隐晦的方式，就是通过继承。因为如果Proxy 继承自RealSubject，这样Proxy则拥有了RealSubject的功能，
 *Proxy还可以通过重写RealSubject中的方法，来实现多态。
 *
 *其中JDK中提供的创建动态代理的机制，是以 a 这种思路设计的，而 cglib 则是以 b 思路设计的。
 */
package com.chen.designpattern.proxy;